# source ~/barcode-env/bin/activate
# python bin/gitlab-commits-export.py --since="2025-06-01T00:00:00" --until="2025-07-01T23:59:59" --output="tangca_thang6.xlsx" --include-working-hours --branch=dev/nam-webform --keyword fix bug urgent

import argparse
import subprocess
import json
from datetime import datetime, time
from collections import defaultdict
from openpyxl import Workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment, Font, PatternFill
from openpyxl.styles.borders import Border, Side

import re

print("üî• ƒêang ch·∫°y file:", __file__)

# H√†m c·∫Øt chu·ªói l·∫•y ph·∫ßn tr∆∞·ªõc d·∫•u '|'
def cut_after_pipe(s):
    return s.split('|', 1)[0].strip()

# H√†m t√¨m OP id trong message d·∫°ng {OP#1234}
def extract_op_id(message):
    m = re.search(r"\{OP#(\d+)\}", message)
    return m.group(1) if m else None

def build_branch_index():
    """
    X√¢y d·ª±ng √°nh x·∫° commit ‚Üí danh s√°ch branch ch·ª©a n√≥.
    D√πng `git for-each-ref` ƒë·ªÉ l·∫•y th√¥ng tin nhanh ch√≥ng.
    """
    try:
        result = subprocess.run(
            ["git", "for-each-ref", "--format=%(objectname)|%(refname:short)", "refs/heads", "refs/remotes/origin"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, check=True, encoding='utf-8'
        )
        lines = result.stdout.strip().splitlines()
        hash_to_branch = defaultdict(list)
        for line in lines:
            parts = line.split("|", 1)
            if len(parts) == 2:
                commit_hash, branch_name = parts
                hash_to_branch[commit_hash].append(branch_name)
        return hash_to_branch
    except Exception as e:
        print("‚ùå L·ªói khi build branch index:", e)
        return {}
    
# Cache k·∫øt qu·∫£ t√¨m branch cho commit hash ƒë·ªÉ tr√°nh g·ªçi git nhi·ªÅu l·∫ßn
_branch_cache = {}
_branch_index = build_branch_index()

def get_branch_for_hash(commit_hash):
    if commit_hash in _branch_cache:
        return _branch_cache[commit_hash]

    # 1. Ki·ªÉm tra trong index
    if commit_hash in _branch_index:
        branches = _branch_index[commit_hash]
        branch_str = ", ".join(branches)
        _branch_cache[commit_hash] = branch_str
        return branch_str

    # 2. N·∫øu kh√¥ng c√≥ trong index, fallback d√πng git
    try:
        result = subprocess.run(
            ["git", "branch", "--contains", commit_hash, "--format=%(refname:short)"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, check=True, encoding='utf-8'
        )
        branches = [line.strip() for line in result.stdout.splitlines() if line.strip()]
        branch_str = ", ".join(branches)

        # L∆∞u cache d√π k·∫øt qu·∫£ r·ªóng
        _branch_cache[commit_hash] = branch_str
        return branch_str
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è L·ªói khi ch·∫°y git branch --contains {commit_hash}: {e}")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh khi t√¨m branch cho {commit_hash}: {e}")

    # fallback cu·ªëi c√πng n·∫øu l·ªói
    _branch_cache[commit_hash] = ""
    return ""

# L·∫•y danh s√°ch commit con c·ªßa m·ªôt merge commit theo author (l·ªçc b·∫±ng --author)
def get_child_commits_by_author(parent, merge_hash, author):
    """
    L·∫•y danh s√°ch commit con trong ph·∫°m vi parent..merge_hash c·ªßa author.
    parent: hash parent (th∆∞·ªùng l√† parent th·ª© 2 c·ªßa merge commit)
    merge_hash: hash merge commit
    author: t√™n t√°c gi·∫£ l·ªçc theo --author
    """
    try:
        result = subprocess.run(
            ["git", "log", f"{parent}..{merge_hash}", "--pretty=format:%h|%an", f"--author={author}"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, check=True, encoding='utf-8'
        )
        lines = result.stdout.strip().splitlines()
        hashes = [line.split("|")[0] for line in lines if line.strip()]
        return hashes
    except Exception:
        return []

# H√†m in b√°o c√°o ra console
def print_console_report(data, count_stat, include_working_hours):
    BOLD = '\033[1m'
    RESET = '\033[0m'
    for author, dates in data.items():
        print("="*60)
        print(f"{BOLD}üë§ T√°c gi·∫£: {author}{RESET}")
        print("="*60)
        for date, commits in sorted(dates.items()):
            print(f"üìÖ Ng√†y: {date.strftime('%d/%m/%Y')}")
            for c in commits:
                print(f"  üïí {c['time']} - üîó {c['hash']} | {c['type']} | [{c['branch']}] | {c['message']}")
                if c['child_commits']:
                    print(f"     ‚Ü≥ G·ªìm commit con: {', '.join(c['child_commits'])}")
        o = count_stat[author]["overtime"]
        w = count_stat[author]["working"]
        summary = f"üî• TƒÉng ca: {o} commit(s)"
        if include_working_hours:
            summary += f" | ‚è∞ Trong gi·ªù: {w} commit(s)"
        print(f"\nüìä {summary}")
        print("."*60)

# --- Ph·∫ßn x·ª≠ l√Ω ch√≠nh ---

# ƒê·ªãnh nghƒ©a tham s·ªë ƒë·∫ßu v√†o cho script
parser = argparse.ArgumentParser(description="B√°o c√°o commit tƒÉng ca: hi·ªÉn th·ªã + xu·∫•t Excel")
parser.add_argument("--author", help="T√°c gi·∫£ (tu·ª≥ ch·ªçn)")
parser.add_argument("--since", default="2025-06-01T00:00:00", help="2025-06-01T00:00:00")
parser.add_argument("--until", default="2025-06-30T23:59:59", help="2025-06-01T00:00:00")
parser.add_argument("--output", default="commits.xlsx", help="commits.xlsx")
parser.add_argument("--include-working-hours", action="store_true", help="Bao g·ªìm c·∫£ commit trong gi·ªù h√†nh ch√≠nh")
parser.add_argument("--branch", help="Ch·ªâ l·∫•y commit thu·ªôc nh√°nh c·ª• th·ªÉ (v√≠ d·ª•: develop, feature/x)")
parser.add_argument("--keyword", nargs="+", help="L·ªçc commit ch·ª©a t·ª´ kh√≥a trong message (vd: fix, bug, urgent)")

args = parser.parse_args()

# T·∫°o command git log v·ªõi format JSON ƒë·ªÉ d·ªÖ parse
git_cmd = ["git", "log"]

# N·∫øu c√≥ --branch th√¨ ch·ªâ l·∫•y log c·ªßa nh√°nh ƒë√≥, ng∆∞·ª£c l·∫°i l·∫•y t·∫•t c·∫£
if args.branch:
    git_cmd.append(args.branch)
else:
    git_cmd.append("--all")

git_cmd += [
    f"--since={args.since}",
    f"--until={args.until}",
    '--pretty=format:%ad\x1f%H\x1f%an\x1f%D\x1f%s\x1f%P',
    "--date=format:%Y-%m-%d %H:%M:%S"
]

if args.author:
    git_cmd.append(f"--author={args.author}")

# Ch·∫°y l·ªánh git log v√† l·∫•y output theo ƒë·ªãnh d·∫°ng ph√¢n c√°ch ƒë·∫∑c bi·ªát
# result = subprocess.run(git_cmd, capture_output=True, text=True)
result = subprocess.run(git_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8')

# Parse t·ª´ng d√≤ng th·ªß c√¥ng, d√πng d·∫•u ph√¢n c√°ch \x1f (Unit Separator)
entries = []
for line in result.stdout.strip().splitlines():
    parts = line.strip().split("\x1f")
    if len(parts) == 6:
        date, hash_, author, ref, msg, parents = parts
        entries.append({
            "date": date.strip(),
            "hash": hash_.strip(),
            "author": author.strip(),
            "ref": ref.strip(),
            "msg": msg.strip(),
            "parents": parents.strip()
        })

# D·ªØ li·ªáu l∆∞u commit theo c·∫•u tr√∫c: author -> ng√†y -> list commit
data = defaultdict(lambda: defaultdict(list))
# Th·ªëng k√™ s·ªë commit tƒÉng ca v√† trong gi·ªù
count_stat = defaultdict(lambda: {"overtime": 0, "working": 0})

# ƒê·ªãnh nghƒ©a gi·ªù l√†m vi·ªác chu·∫©n
start_work = time(8, 0)
end_work = time(17, 30)

# Duy·ªát t·ª´ng commit trong danh s√°ch
for entry in entries:
    try:
        dt = datetime.strptime(entry["date"], "%Y-%m-%d %H:%M:%S")

        # B·ªè qua n·∫øu kh√¥ng kh·ªõp t·ª´ kh√≥a (n·∫øu c√≥ ch·ªâ ƒë·ªãnh)
        if args.keyword:
            msg_lower = entry["msg"].lower()
            if not any(kw.lower() in msg_lower for kw in args.keyword):
                continue

        # X√°c ƒë·ªãnh commit ngo√†i gi·ªù n·∫øu gi·ªù commit kh√¥ng n·∫±m trong khung l√†m vi·ªác
        is_overtime = not (start_work <= dt.time() <= end_work)

        # N·∫øu kh√¥ng mu·ªën include commit trong gi·ªù l√†m th√¨ b·ªè qua
        if not args.include_working_hours and not is_overtime:
            continue

        # L·∫•y t√™n author, l·ªçc b·ªè ph·∫ßn sau d·∫•u '|'
        author = cut_after_pipe(entry["author"])

        # L·∫•y th√¥ng tin ref (nh√°nh, tag,...)
        ref_info = entry["ref"].strip()

        # M√£ commit hash
        commit_hash = entry["hash"].strip()

        # L·∫•y danh s√°ch cha c·ªßa commit (ƒë·ªÉ x√°c ƒë·ªãnh merge)
        parents = entry.get("parents", "").strip().split()

        # X√°c ƒë·ªãnh commit merge hay b√¨nh th∆∞·ªùng
        is_merge = len(parents) > 1

        # L·∫•y commit con c·ªßa merge do author n√†y t·∫°o ra (n·∫øu l√† merge)
        child_commits = []
        if is_merge and len(parents) > 1:
            # L·∫•y parent th·ª© 2 l√†m ƒëi·ªÉm b·∫Øt ƒë·∫ßu ph·∫°m vi log commit con
            child_commits = get_child_commits_by_author(parents[1], commit_hash, author)

        # X√°c ƒë·ªãnh type commit (merge-with-contribution, merge-only, commit)
        commit_type = (
            "merge-with-contribution" if is_merge and child_commits else
            "merge-only" if is_merge else
            "commit"
        )

        # X√°c ƒë·ªãnh branch theo th·ª© t·ª± ∆∞u ti√™n:
        branch = ""
        m = re.search(r'HEAD -> ([^,\s]+)', ref_info)
        if m:
            branch = m.group(1)
        elif "origin/" in ref_info:
            m = re.search(r'origin/([^,\s]+)', ref_info)
            if m:
                branch = m.group(1)
        elif ref_info:
            branch = ref_info.split(",")[0].strip()

        # N·∫øu v·∫´n ch∆∞a c√≥ branch, g·ªçi git ƒë·ªÉ l·∫•y
        if not branch:
            branch = get_branch_for_hash(commit_hash)

        # Chu·∫©n h√≥a l·∫°i t√™n hi·ªÉn th·ªã branch
        branch = re.sub(r"^origin/", "", branch)

        # L∆∞u d·ªØ li·ªáu commit v√†o dict theo author v√† ng√†y
        data[author][dt.date()].append({
            "time": dt.strftime("%H:%M"),
            "hash": commit_hash,
            "message": entry["msg"].strip(),
            "branch": branch,
            "event": "merge" if is_merge else "commit",
            "type": commit_type,
            "child_commits": child_commits,
            "is_overtime": is_overtime
        })

        # C·∫≠p nh·∫≠t th·ªëng k√™ tƒÉng ca ho·∫∑c trong gi·ªù
        if is_overtime:
            count_stat[author]["overtime"] += 1
        else:
            count_stat[author]["working"] += 1

    except Exception as e:
        print(f"‚ùóÔ∏èL·ªói x·ª≠ l√Ω commit {entry.get('hash', 'unknown')} ({entry.get('msg', '')[:50]}...): {e}")
        continue

# In b√°o c√°o ra console
print_console_report(data, count_stat, args.include_working_hours)

# ------- Xu·∫•t Excel -------
thick_top = Border(top=Side(style='thin'))
thin_top = Border(top=Side(style='thin'))  # ho·∫∑c style='medium' n·∫øu b·∫°n mu·ªën ƒë·∫≠m h∆°n

wb = Workbook()
ws = wb.active
ws.title = "TƒÉng ca"

headers = ["T√°c gi·∫£", "Ng√†y", "Th·ªùi gian", "M√£ commit", "Event", "Type", "Branch", "N·ªôi dung", "OP Link", "Child Commits"]
ws.append(headers)

header_fill = PatternFill(start_color="FFD580", end_color="FFD580", fill_type="solid")  # Cam nh·∫°t
summary_fill = PatternFill(start_color="FFFACD", end_color="FFFACD", fill_type="solid")
highlight_fill = PatternFill(start_color="FFC07F", end_color="FFC07F", fill_type="solid")  # Lavender
alt_row_fill = PatternFill(start_color="E0E0E0", end_color="E0E0E0", fill_type="solid")  # N·ªÅn xen k·∫Ω

for col in range(1, len(headers) + 1):
    cell = ws.cell(row=1, column=col)
    cell.font = Font(bold=True)
    cell.fill = header_fill
    cell.alignment = Alignment(horizontal="center", vertical="center")

ws.freeze_panes = "A2"
row = 2
first_author = True
for author, dates in data.items():
    if not first_author:
        # Ch·ªâ th√™m d√≤ng tr·ªëng n·∫øu kh√¥ng ph·∫£i t√°c gi·∫£ ƒë·∫ßu ti√™n
        ws.append([""] * len(headers))
        row += 1
    else:
        first_author = False

    author_start_row = row

    for date, commits in sorted(dates.items()):
        date_start_row = row
        for c in commits:
            op_id = extract_op_id(c["message"])
            row_data = [
                author,
                date.strftime("%d/%m/%Y"),
                c["time"],
                c["hash"],
                c["event"],
                c["type"],
                c["branch"],
                c["message"],
                op_id if op_id else "",
                ", ".join(c["child_commits"]) if c["child_commits"] else ""
            ]
            ws.append(row_data)
            # T√¥ m√†u xen k·∫Ω cho d√≤ng ch·∫µn, nh∆∞ng ch·ªâ n·∫øu kh√¥ng ph·∫£i d√≤ng merged ho·∫∑c t·ªïng k·∫øt
            if row_data[0] != "" and row_data[1] != "":  # Kh√¥ng ph·∫£i d√≤ng merge
                if row % 2 == 0:
                    for col_idx in range(1, len(headers) + 1):
                        ws.cell(row=row, column=col_idx).fill = alt_row_fill


            # T·∫°o hyperlink n·∫øu c√≥ OP link
            if op_id:
                ws.cell(row=row, column=9).hyperlink = f"https://work.fsofts.com/work_packages/{op_id}"
                ws.cell(row=row, column=9).style = "Hyperlink"

            # Canh ch·ªânh text trong c√°c √¥
            for col_idx in range(1, len(headers) + 1):
                ws.cell(row=row, column=col_idx).alignment = Alignment(vertical="top", horizontal="left")

            # In ƒë·∫≠m c·ªôt Event v√† Type n·∫øu l√† merge
            if c["event"] == "merge":
                for col_idx in (5, 6):  # c·ªôt E v√† F
                    ws.cell(row=row, column=col_idx).font = Font(bold=True)

            # T√¥ m√†u c·ªôt th·ªùi gian n·∫øu l√† commit tƒÉng ca
            if c["is_overtime"]:
                ws.cell(row=row, column=3).fill = highlight_fill

            row += 1

        # # G·ªôp √¥ cho c·ªôt ng√†y n·∫øu nhi·ªÅu commit trong ng√†y
        # date_end_row = row - 1
        # if date_end_row > date_start_row:
        #     ws.merge_cells(start_row=date_start_row, end_row=date_end_row, start_column=2, end_column=2)
        #     for r in range(date_start_row, date_end_row + 1):
        #         ws.cell(r, 2).alignment = Alignment(horizontal="center", vertical="top")
        # else:
        #     ws.cell(date_start_row, 2).alignment = Alignment(horizontal="center", vertical="top")
        
        # Ch·ªâ ƒëi·ªÅn gi√° tr·ªã ng√†y ·ªü d√≤ng ƒë·∫ßu ti√™n, c√°c d√≤ng c√≤n l·∫°i ƒë·ªÉ tr·ªëng
        for r in range(date_start_row + 1, row):
            ws.cell(r, 2).value = ""

    # # G·ªôp √¥ cho c·ªôt t√°c gi·∫£ n·∫øu nhi·ªÅu ng√†y
    # author_end_row = row - 1
    # if author_end_row > author_start_row:
    #     ws.merge_cells(start_row=author_start_row, end_row=author_end_row, start_column=1, end_column=1)
    #     for r in range(author_start_row, author_end_row + 1):
    #         for col in range(1, 11):  # C·ªôt A ‚Üí J (1 ‚Üí 10)
    #             cell = ws.cell(r, col)
    #             if col == 1:
    #                 cell.alignment = Alignment(horizontal="left", vertical="top")
    #                 cell.font = Font(bold=True)
    #             if r == author_start_row:
    #                 cell.border = thick_top
    
    # Ghi t√™n t√°c gi·∫£ ·ªü d√≤ng ƒë·∫ßu ti√™n, c√°c d√≤ng c√≤n l·∫°i ƒë·ªÉ tr·ªëng
    for r in range(author_start_row, row):
        cell = ws.cell(r, 1)
        if r == author_start_row:
            cell.value = author
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal="left", vertical="top")
            cell.fill = PatternFill(start_color="FFFACD", end_color="FFFACD", fill_type="solid")

            # Border top cho c·∫£ h√†ng
            for col_idx in range(1, len(headers) + 1):
                ws.cell(r, col_idx).border = Border(top=Side(style='medium'))
        else:
            cell.value = ""


    # Th√™m d√≤ng t·ªïng k·∫øt s·ªë commit
    o = count_stat[author]["overtime"]
    w = count_stat[author]["working"]
    summary = f"TƒÉng ca: {o} commits"
    if args.include_working_hours:
        summary += f" | Trong gi·ªù: {w} commits"

    full_summary = f"T·ªïng c·ªông: {summary}"
    ws.append([full_summary])

    # G·ªôp d√≤ng t·ªïng k·∫øt t·ª´ c·ªôt A ‚Üí J
    ws.merge_cells(start_row=row, end_row=row, start_column=1, end_column=10)
    merged_cell = ws.cell(row=row, column=1)
    merged_cell.alignment = Alignment(horizontal="left", vertical="top")
    merged_cell.fill = summary_fill
    merged_cell.font = Font(bold=True)

    row += 1

# T·ª± ƒë·ªông ch·ªânh l·∫°i chi·ªÅu r·ªông c·ªôt, gi·ªõi h·∫°n t·ªëi ƒëa 30 k√Ω t·ª±
MAX_WIDTH = 30
for col in ws.columns:
    max_len = 0
    col_letter = get_column_letter(col[0].column)
    for cell in col[1:]:  # B·ªè header
        try:
            cell_value = str(cell.value or "")
        except:
            cell_value = ""
        if len(cell_value) > max_len:
            max_len = len(cell_value)
    max_len = min(max_len, MAX_WIDTH)
    ws.column_dimensions[col_letter].width = max(max_len + 1, 8)

# L∆∞u file Excel
wb.save(args.output)
print(f"\n‚úÖ ƒê√£ xu·∫•t file Excel: {args.output}")
